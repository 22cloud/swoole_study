# 前言
前文再续，就书接上一回，经过了各种突发事件的2016后，笔者终于苟延残喘到了传说中的2017，去年我们简单聊了Swoole的进程模型，这次俺们来聊聊热重载的问题。

> 在这个普天同庆的元旦里，祝愿大伙身体健康，平平安安～

# 重载之初

在传统的LAMP环境中，我们调试应用有时候非常简单，修改，保存，重新访问，就能看到刚刚修改的代码的效果，所以很多童鞋都习惯了随改随用，可这个随改随用的过程中，发生了什么呢？

> 详细可以回顾笔者之前的文章…

在笔者以前的文章中，我们已经聊过了LAMP架构中一个WEB请求的处理过程，现在我们来关注一下这个过程中为什么我们的代码可以实现随改随用？

每当apache收到请求的时候，都会先从当前已经加载到内存中的配置，决定应该尝试调用哪个php文件，把

# 沟通与协作

我们先假设有如下的Swoole进程正在工作：

``` shell
# 这个名称只是示意，并非真实的运行情况
-php swoole_master
    |-php swoole_manager
        |-php swoole_worker_01
        |-php swoole_worker_02
```

正如我们上次聊的那样，master进程收到了客户端的请求以后，解决了TCP级别的协议问题后，就把请求交给了manager进程处理，而manager进程则会进一步的把工作交给worker，最后的业务逻辑是在woeker中完成的。

> 这是个很经典的异步协同工作流程。

在这个过程中，进程之间是怎么协作的呢？想象一下，现在来了一个请求，但有两个worker都可以处理，manager应该分给谁呢？

> 从上一章我们已经知道，worker之间都是孪生兄弟的关系

效率上，我们一般会这样考虑，谁有空就给谁就好了，但实际上，效率问题只是一部分，更多的问题存在于业务逻辑中，这里，我们要先聊聊另一位可能既熟悉又陌生的老朋友——

## Session

相信很多童鞋对Session都不陌生，一般的应用场景中，Session会在有限的时间内保持用户的会话状态（默认是1440秒），当用户超过这个时间没有向服务端发送消息的时候，服务端就会认为这个用户的会话已经结束了。

> 会话超时也往往意味着登录结束了

那么

# 小番外：配置的故事

想了很久，发现有些东西专门开个章节不好讲，不讲又有遗漏，就增加这个栏目，专门讲一些比较简单也比较好理解的东西

## max_request

## max_connection
