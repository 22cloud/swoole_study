# 前言
前文再续，就书接上一回，经过了各种突发事件的2016后，笔者终于苟延残喘到了传说中的2017，去年我们简单聊了Swoole的进程模型，这次俺们来聊聊热重载的问题。

> 在这个普天同庆的元旦里，祝愿大伙身体健康，平平安安～

# 重载之初

在传统的LAMP环境中，我们调试应用有时候非常简单，修改，保存，重新访问，就能看到刚刚修改的代码的效果，所以很多童鞋都习惯了随改随用，可是当业务来到Swoole Server的时候，却发现了一些不同。

```php
// 篇幅原因，省略其他代码，我们仅来看看OnReceive的时候
$server->on('receive', function ($serv, $fd, $from_id, $data){
    echo "Receive something\n";
});
```

这段DEMO的逻辑非常简单，每当Server收到一个包的时候，输出一段文字。我们来模拟一个业务调整的场景，希望Server在收到包的时候，输出两段文字，现在我们简单修改一下代码如下并保存：

```php
// 篇幅原因，省略其他代码，我们仅来看看OnReceive的时候
$server->on('receive', function ($serv, $fd, $from_id, $data){
    echo "Receive something\n";
    echo "I can not receive anything\n"
});
```

然后再使用telnet作为测试工具，向Server发出请求，然后就像很多童鞋学习过程中遇到的那样，输出仍然是“Receive something\n”，后加的“I can not receive anything\n”并不会出现。

> 这个结果与我们习惯中即插即用的php表现并不相同。

这是什么情况呢？我们把当前Server相关进程干掉，然后重启服务看看？没错，如我们预期的那样，如果把Server干掉并重启，确实会使得刚刚更新代码生效，可是，正如笔者在拙作《当SWOOLE遇上TCP》中说的，一个TCP连接就像打电话，如果每次业务重置都要挂掉当前的所有电话，那么分分钟会出现做了一半的业务没有全部完成的情况。

> 数据库中的事务性操作，或者我们常说的原子操作，在业务层面上也可以成立。

这显然是不合适的，也不利于我们进行调试，那么


在笔者以前的文章中，我们已经聊过了LAMP架构中一个WEB请求的处理过程，现在我们来关注一下这个过程中为什么我们的代码可以实现随改随用？

每当apache收到请求的时候，都会先从当前已经加载到内存中的配置，决定应该尝试调用哪个php文件，把

# 沟通与协作

我们先假设有如下的Swoole进程正在工作：

``` shell
# 这个名称只是示意，并非真实的运行情况
-php swoole_master
    |-php swoole_manager
        |-php swoole_worker_01
        |-php swoole_worker_02
```

正如我们上次聊的那样，master进程收到了客户端的请求以后，解决了TCP级别的协议问题后，就把请求交给了manager进程处理，而manager进程则会进一步的把工作交给worker，最后的业务逻辑是在woeker中完成的。

> 这是个很经典的异步协同工作流程。

在这个过程中，进程之间是怎么协作的呢？想象一下，现在来了一个请求，但有两个worker都可以处理，manager应该分给谁呢？

> 从上一章我们已经知道，worker之间都是孪生兄弟的关系

效率上，我们一般会这样考虑，谁有空就给谁就好了，但实际上，效率问题只是一部分，更多的问题存在于业务逻辑中，这里，我们要先聊聊另一位可能既熟悉又陌生的老朋友——

## Session

相信很多童鞋对Session都不陌生，一般的应用场景中，Session会在有限的时间内保持用户的会话状态（默认是1440秒），当用户超过这个时间没有向服务端发送消息的时候，服务端就会认为这个用户的会话已经结束了。

> 会话超时也往往意味着登录结束了

那么

# 小番外：配置的故事

想了很久，发现有些东西专门开个章节不好讲，不讲又有遗漏，就增加这个栏目，专门讲一些比较简单也比较好理解的东西

## max_request

## max_connection
